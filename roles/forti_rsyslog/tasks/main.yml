---
- name: Validate configuration - at least one protocol enabled
  ansible.builtin.assert:
    that:
      - forti_syslog_enable_udp or forti_syslog_enable_tcp
    fail_msg: >-
      Enable at least one protocol: forti_syslog_enable_udp and/or forti_syslog_enable_tcp.

- name: Validate retention days
  ansible.builtin.assert:
    that:
      - (forti_log_retention_days | int) > 0
    fail_msg: "forti_log_retention_days must be a positive integer (e.g., 14, 30, 60)."

- name: Validate UDP port
  ansible.builtin.assert:
    that:
      - (forti_syslog_udp_port | int) > 0
      - (forti_syslog_udp_port | int) < 65536
  when: forti_syslog_enable_udp

- name: Validate TCP port
  ansible.builtin.assert:
    that:
      - (forti_syslog_tcp_port | int) > 0
      - (forti_syslog_tcp_port | int) < 65536
  when: forti_syslog_enable_tcp

- name: Install rsyslog and logrotate
  ansible.builtin.package:
    name:
      - rsyslog
      - logrotate
    state: present

- name: Ensure Fortinet log directory exists
  ansible.builtin.file:
    path: "{{ forti_log_dir }}"
    state: directory
    owner: "{{ forti_log_owner }}"
    group: "{{ forti_log_group }}"
    mode: "{{ forti_log_dir_mode }}"

- name: Ensure Fortinet log file exists (so Wazuh can tail it immediately)
  ansible.builtin.file:
    path: "{{ forti_log_path }}"
    state: touch
    owner: "{{ forti_log_owner }}"
    group: "{{ forti_log_group }}"
    mode: "{{ forti_log_file_mode }}"

- name: Deploy rsyslog configuration for Fortinet
  ansible.builtin.template:
    src: fortinet-rsyslog.conf.j2
    dest: "{{ forti_rsyslog_conf_path }}"
    owner: root
    group: root
    mode: "0644"
  notify: Restart rsyslog

- name: Deploy logrotate configuration for Fortinet logs
  ansible.builtin.template:
    src: fortinet-logrotate.conf.j2
    dest: "{{ forti_logrotate_conf_path }}"
    owner: root
    group: root
    mode: "0644"

- name: Ensure rsyslog is enabled and started
  ansible.builtin.service:
    name: "{{ rsyslog_service_name }}"
    state: started
    enabled: true

# Apply pending rsyslog config changes before health checks.
- name: Flush rsyslog handlers before health checks
  ansible.builtin.meta: flush_handlers
  when: forti_rsyslog_healthcheck

- name: Wait briefly for rsyslog to bind listeners
  ansible.builtin.pause:
    seconds: "{{ forti_rsyslog_healthcheck_delay }}"
  when:
    - forti_rsyslog_healthcheck
    - (forti_rsyslog_healthcheck_delay | int) > 0

# --- rsyslog health checks ---
- name: Initialize rsyslog health check issues
  ansible.builtin.set_fact:
    forti_rsyslog_health_issues: []
  when: forti_rsyslog_healthcheck

- name: Gather service facts (rsyslog)
  ansible.builtin.service_facts:
  when: forti_rsyslog_healthcheck

- name: Determine rsyslog service facts key
  ansible.builtin.set_fact:
    forti_rsyslog_service_key: >-
      {{ rsyslog_service_name if (rsyslog_service_name in ansible_facts.services)
         else (rsyslog_service_name ~ '.service') if ((rsyslog_service_name ~ '.service') in ansible_facts.services)
         else '' }}
  when: forti_rsyslog_healthcheck

- name: Evaluate rsyslog service state
  ansible.builtin.set_fact:
    forti_rsyslog_service_running: >-
      {{ (forti_rsyslog_service_key != '') and
         (ansible_facts.services[forti_rsyslog_service_key].state == 'running') }}
  when: forti_rsyslog_healthcheck

- name: Flag rsyslog service not running
  ansible.builtin.set_fact:
    forti_rsyslog_health_issues: >-
      {{ forti_rsyslog_health_issues + ["rsyslog service '" ~ rsyslog_service_name ~ "' is not running or not detected."] }}
  when:
    - forti_rsyslog_healthcheck
    - not forti_rsyslog_service_running

- name: Check Fortinet log path
  ansible.builtin.stat:
    path: "{{ forti_log_path }}"
  register: forti_rsyslog_log_path_stat
  when: forti_rsyslog_healthcheck

- name: Flag missing Fortinet log path
  ansible.builtin.set_fact:
    forti_rsyslog_health_issues: >-
      {{ forti_rsyslog_health_issues + ["Fortinet log path '" ~ forti_log_path ~ "' does not exist."] }}
  when:
    - forti_rsyslog_healthcheck
    - not forti_rsyslog_log_path_stat.stat.exists

- name: Detect socket inspection tool
  ansible.builtin.shell: "command -v ss || command -v netstat"
  register: forti_rsyslog_sock_tool
  changed_when: false
  failed_when: false
  when:
    - forti_rsyslog_healthcheck
    - forti_syslog_enable_tcp or forti_syslog_enable_udp

- name: Flag missing socket inspection tool
  ansible.builtin.set_fact:
    forti_rsyslog_health_issues: >-
      {{ forti_rsyslog_health_issues + ['Unable to verify rsyslog ports because neither ss nor netstat is available.'] }}
  when:
    - forti_rsyslog_healthcheck
    - forti_syslog_enable_tcp or forti_syslog_enable_udp
    - forti_rsyslog_sock_tool.stdout | trim | length == 0

- name: Capture TCP listeners
  ansible.builtin.command: "{{ forti_rsyslog_sock_tool.stdout | trim }} -lnt"
  register: forti_rsyslog_tcp_listen
  changed_when: false
  failed_when: false
  when:
    - forti_rsyslog_healthcheck
    - forti_syslog_enable_tcp
    - forti_rsyslog_sock_tool.stdout | trim | length > 0

- name: Evaluate TCP listener
  ansible.builtin.set_fact:
    forti_rsyslog_tcp_listening: >-
      {{ (forti_rsyslog_tcp_listen.rc == 0) and
         ((forti_rsyslog_tcp_listen.stdout | regex_search(':' ~ (forti_syslog_tcp_port | string) ~ '(\\s|$)')) is not none) }}
  when:
    - forti_rsyslog_healthcheck
    - forti_syslog_enable_tcp
    - forti_rsyslog_sock_tool.stdout | trim | length > 0

- name: Recheck TCP listener with retries
  ansible.builtin.shell: |
    attempts={{ forti_rsyslog_healthcheck_retries | int }}
    delay={{ forti_rsyslog_healthcheck_retry_delay | int }}
    i=0
    while [ $i -lt "$attempts" ]; do
      {{ forti_rsyslog_sock_tool.stdout | trim }} -lnt | grep -Eq ":{{ forti_syslog_tcp_port | string }}([[:space:]]|$)" && exit 0
      i=$((i+1))
      sleep "$delay"
    done
    exit 1
  register: forti_rsyslog_tcp_recheck
  changed_when: false
  failed_when: false
  when:
    - forti_rsyslog_healthcheck
    - forti_syslog_enable_tcp
    - forti_rsyslog_sock_tool.stdout | trim | length > 0
    - not forti_rsyslog_tcp_listening

- name: Update TCP listener status after retry
  ansible.builtin.set_fact:
    forti_rsyslog_tcp_listening: >-
      {{ forti_rsyslog_tcp_listening or (forti_rsyslog_tcp_recheck.rc == 0) }}
  when:
    - forti_rsyslog_healthcheck
    - forti_syslog_enable_tcp
    - forti_rsyslog_sock_tool.stdout | trim | length > 0
    - not forti_rsyslog_tcp_listening

- name: Flag TCP port not listening
  ansible.builtin.set_fact:
    forti_rsyslog_health_issues: >-
      {{ forti_rsyslog_health_issues + ['rsyslog TCP port ' ~ (forti_syslog_tcp_port | string) ~ ' is not listening.'] }}
  when:
    - forti_rsyslog_healthcheck
    - forti_syslog_enable_tcp
    - forti_rsyslog_sock_tool.stdout | trim | length > 0
    - not forti_rsyslog_tcp_listening

- name: Capture UDP listeners
  ansible.builtin.command: "{{ forti_rsyslog_sock_tool.stdout | trim }} -lnu"
  register: forti_rsyslog_udp_listen
  changed_when: false
  failed_when: false
  when:
    - forti_rsyslog_healthcheck
    - forti_syslog_enable_udp
    - forti_rsyslog_sock_tool.stdout | trim | length > 0

- name: Evaluate UDP listener
  ansible.builtin.set_fact:
    forti_rsyslog_udp_listening: >-
      {{ (forti_rsyslog_udp_listen.rc == 0) and
         ((forti_rsyslog_udp_listen.stdout | regex_search(':' ~ (forti_syslog_udp_port | string) ~ '(\\s|$)')) is not none) }}
  when:
    - forti_rsyslog_healthcheck
    - forti_syslog_enable_udp
    - forti_rsyslog_sock_tool.stdout | trim | length > 0

- name: Recheck UDP listener with retries
  ansible.builtin.shell: |
    attempts={{ forti_rsyslog_healthcheck_retries | int }}
    delay={{ forti_rsyslog_healthcheck_retry_delay | int }}
    i=0
    while [ $i -lt "$attempts" ]; do
      {{ forti_rsyslog_sock_tool.stdout | trim }} -lnu | grep -Eq ":{{ forti_syslog_udp_port | string }}([[:space:]]|$)" && exit 0
      i=$((i+1))
      sleep "$delay"
    done
    exit 1
  register: forti_rsyslog_udp_recheck
  changed_when: false
  failed_when: false
  when:
    - forti_rsyslog_healthcheck
    - forti_syslog_enable_udp
    - forti_rsyslog_sock_tool.stdout | trim | length > 0
    - not forti_rsyslog_udp_listening

- name: Update UDP listener status after retry
  ansible.builtin.set_fact:
    forti_rsyslog_udp_listening: >-
      {{ forti_rsyslog_udp_listening or (forti_rsyslog_udp_recheck.rc == 0) }}
  when:
    - forti_rsyslog_healthcheck
    - forti_syslog_enable_udp
    - forti_rsyslog_sock_tool.stdout | trim | length > 0
    - not forti_rsyslog_udp_listening

- name: Flag UDP port not listening
  ansible.builtin.set_fact:
    forti_rsyslog_health_issues: >-
      {{ forti_rsyslog_health_issues + ['rsyslog UDP port ' ~ (forti_syslog_udp_port | string) ~ ' is not listening.'] }}
  when:
    - forti_rsyslog_healthcheck
    - forti_syslog_enable_udp
    - forti_rsyslog_sock_tool.stdout | trim | length > 0
    - not forti_rsyslog_udp_listening

- name: Fail if rsyslog health checks failed
  ansible.builtin.fail:
    msg: |-
      rsyslog is not working in Ansible:
      - {{ forti_rsyslog_health_issues | join('\n- ') }}
  when:
    - forti_rsyslog_healthcheck
    - forti_rsyslog_healthcheck_fail
    - forti_rsyslog_health_issues | length > 0

- name: Warn if rsyslog health checks failed
  ansible.builtin.debug:
    msg: |-
      rsyslog is not working in Ansible:
      - {{ forti_rsyslog_health_issues | join('\n- ') }}
  when:
    - forti_rsyslog_healthcheck
    - not forti_rsyslog_healthcheck_fail
    - forti_rsyslog_health_issues | length > 0

# --- Wazuh integration ---
- name: Check for Wazuh ossec.conf
  ansible.builtin.stat:
    path: "{{ forti_wazuh_ossec_conf_path }}"
  register: wazuh_ossec_conf
  when: forti_wazuh_manage

- name: Fail if Wazuh ossec.conf does not exist
  ansible.builtin.fail:
    msg: >-
      Wazuh config not found at {{ forti_wazuh_ossec_conf_path }}.
      Set forti_wazuh_ossec_conf_path to the correct ossec.conf location
      or set forti_wazuh_manage=false to configure rsyslog only.
  when:
    - forti_wazuh_manage
    - forti_wazuh_fail_if_missing
    - not wazuh_ossec_conf.stat.exists

- name: Ensure Wazuh logall is configured (ossec.conf)
  ansible.builtin.lineinfile:
    path: "{{ forti_wazuh_ossec_conf_path }}"
    regexp: '^\s*<logall>.*</logall>'
    line: "  <logall>{{ forti_wazuh_logall }}</logall>"
    insertafter: '^\s*<global>'
  when:
    - forti_wazuh_manage
    - wazuh_ossec_conf.stat.exists
    - forti_wazuh_manage_logall
  notify: Restart wazuh-manager

- name: Ensure Wazuh logall_json is configured (ossec.conf)
  ansible.builtin.lineinfile:
    path: "{{ forti_wazuh_ossec_conf_path }}"
    regexp: '^\s*<logall_json>.*</logall_json>'
    line: "  <logall_json>{{ forti_wazuh_logall_json }}</logall_json>"
    insertafter: '^\s*<global>'
  when:
    - forti_wazuh_manage
    - wazuh_ossec_conf.stat.exists
    - forti_wazuh_manage_logall_json
  notify: Restart wazuh-manager

- name: Check for Filebeat Wazuh module config
  ansible.builtin.stat:
    path: "{{ forti_wazuh_filebeat_module_path }}"
  register: forti_wazuh_filebeat_module
  when:
    - forti_wazuh_manage
    - forti_wazuh_filebeat_manage

- name: Check for Filebeat config
  ansible.builtin.stat:
    path: "{{ forti_wazuh_filebeat_config_path }}"
  register: forti_wazuh_filebeat_config
  when:
    - forti_wazuh_manage
    - forti_wazuh_filebeat_manage

- name: Warn if Filebeat config is missing
  ansible.builtin.debug:
    msg: >-
      Filebeat config not found at {{ forti_wazuh_filebeat_config_path }}.
      Archives shipping configuration may be skipped.
  when:
    - forti_wazuh_manage
    - forti_wazuh_filebeat_manage
    - not forti_wazuh_filebeat_config.stat.exists

- name: Warn if Filebeat Wazuh module config is missing
  ansible.builtin.debug:
    msg: >-
      Filebeat Wazuh module config not found at {{ forti_wazuh_filebeat_module_path }}.
      Falling back to filebeat.inputs if enabled.
  when:
    - forti_wazuh_manage
    - forti_wazuh_filebeat_manage
    - not forti_wazuh_filebeat_module.stat.exists

- name: Check for filebeat.inputs section
  ansible.builtin.command: "grep -Eq '^filebeat\\.inputs:' {{ forti_wazuh_filebeat_config_path }}"
  register: forti_wazuh_filebeat_inputs_section
  changed_when: false
  failed_when: false
  when:
    - forti_wazuh_manage
    - forti_wazuh_filebeat_manage
    - forti_wazuh_filebeat_inputs_manage
    - forti_wazuh_filebeat_config.stat.exists

- name: Insert archives input under filebeat.inputs
  ansible.builtin.blockinfile:
    path: "{{ forti_wazuh_filebeat_config_path }}"
    marker: "# {mark} ANSIBLE MANAGED FORTI WAZUH ARCHIVES INPUT"
    insertafter: '^filebeat\.inputs:'
    block: |2
      - type: log
        enabled: {{ "true" if forti_wazuh_filebeat_archives_enabled else "false" }}
        paths:
      {%- for path in forti_wazuh_filebeat_archives_paths %}
          - {{ path }}
      {%- endfor %}
  when:
    - forti_wazuh_manage
    - forti_wazuh_filebeat_manage
    - forti_wazuh_filebeat_inputs_manage
    - forti_wazuh_filebeat_config.stat.exists
    - not forti_wazuh_filebeat_module.stat.exists
    - forti_wazuh_filebeat_inputs_section.rc == 0
  notify: Restart filebeat

- name: Add filebeat.inputs with archives input
  ansible.builtin.blockinfile:
    path: "{{ forti_wazuh_filebeat_config_path }}"
    marker: "# {mark} ANSIBLE MANAGED FORTI WAZUH ARCHIVES INPUT"
    block: |2
      filebeat.inputs:
      - type: log
        enabled: {{ "true" if forti_wazuh_filebeat_archives_enabled else "false" }}
        paths:
      {%- for path in forti_wazuh_filebeat_archives_paths %}
          - {{ path }}
      {%- endfor %}
  when:
    - forti_wazuh_manage
    - forti_wazuh_filebeat_manage
    - forti_wazuh_filebeat_inputs_manage
    - forti_wazuh_filebeat_config.stat.exists
    - not forti_wazuh_filebeat_module.stat.exists
    - forti_wazuh_filebeat_inputs_section.rc != 0
  notify: Restart filebeat

- name: Check for archives block in Filebeat Wazuh module config
  ansible.builtin.command: "grep -Eq '^[[:space:]]*archives:' {{ forti_wazuh_filebeat_module_path }}"
  register: forti_wazuh_filebeat_archives_block
  changed_when: false
  failed_when: false
  when:
    - forti_wazuh_manage
    - forti_wazuh_filebeat_manage
    - forti_wazuh_filebeat_module.stat.exists

- name: Update archives enabled in Filebeat Wazuh module config
  ansible.builtin.replace:
    path: "{{ forti_wazuh_filebeat_module_path }}"
    regexp: '(?ms)^([ \t]*archives:\s*\n(?:^[ \t]+.*\n)*?^[ \t]+enabled:\s*)(true|false)'
    replace: '\1{{ "true" if forti_wazuh_filebeat_archives_enabled else "false" }}'
  when:
    - forti_wazuh_manage
    - forti_wazuh_filebeat_manage
    - forti_wazuh_filebeat_module.stat.exists
    - forti_wazuh_filebeat_archives_block.rc == 0
  notify: Restart filebeat

- name: Insert archives block in Filebeat Wazuh module config
  ansible.builtin.blockinfile:
    path: "{{ forti_wazuh_filebeat_module_path }}"
    marker: "# {mark} ANSIBLE MANAGED FORTI WAZUH ARCHIVES"
    insertafter: '^\s*- module:\s*wazuh\s*$'
    block: |2
      archives:
        enabled: {{ "true" if forti_wazuh_filebeat_archives_enabled else "false" }}
        var.paths:
      {%- for path in forti_wazuh_filebeat_archives_paths %}
          - {{ path }}
      {%- endfor %}
  when:
    - forti_wazuh_manage
    - forti_wazuh_filebeat_manage
    - forti_wazuh_filebeat_module.stat.exists
    - forti_wazuh_filebeat_archives_block.rc != 0
  notify: Restart filebeat

- name: Gather service facts (filebeat)
  ansible.builtin.service_facts:
  when:
    - forti_wazuh_manage
    - forti_wazuh_filebeat_manage
    - forti_wazuh_filebeat_module.stat.exists or forti_wazuh_filebeat_config.stat.exists

- name: Determine if Filebeat service exists
  ansible.builtin.set_fact:
    forti_filebeat_service_present: "{{ forti_filebeat_service_name in ansible_facts.services }}"
  when:
    - forti_wazuh_manage
    - forti_wazuh_filebeat_manage
    - forti_wazuh_filebeat_module.stat.exists or forti_wazuh_filebeat_config.stat.exists

- name: Gather service facts (for safe Wazuh restarts)
  ansible.builtin.service_facts:
  when:
    - forti_wazuh_manage
    - wazuh_ossec_conf.stat.exists

- name: Determine if Wazuh manager service exists
  ansible.builtin.set_fact:
    forti_wazuh_service_present: "{{ forti_wazuh_manager_service_name in ansible_facts.services }}"
  when:
    - forti_wazuh_manage
    - wazuh_ossec_conf.stat.exists

- name: Add Fortinet localfile entry to Wazuh (ossec.conf)
  ansible.builtin.blockinfile:
    path: "{{ forti_wazuh_ossec_conf_path }}"
    marker: "<!-- {mark} ANSIBLE MANAGED FORTI SYSLOG -->"
    insertbefore: "{{ forti_wazuh_insert_before_regex }}"
    block: |2
      <localfile>
        <location>{{ forti_log_path }}</location>
        <log_format>{{ forti_wazuh_log_format }}</log_format>
      </localfile>
  when:
    - forti_wazuh_manage
    - wazuh_ossec_conf.stat.exists
  notify: Restart wazuh-manager

- name: Warn if Wazuh service was not detected (restart skipped)
  ansible.builtin.debug:
    msg: >-
      Wazuh manager service '{{ forti_wazuh_manager_service_name }}' was not found via service_facts.
      ossec.conf was updated, but automatic restart was skipped. Restart Wazuh manually or set the correct
      forti_wazuh_manager_service_name.
  when:
    - forti_wazuh_manage
    - wazuh_ossec_conf.stat.exists
    - not (forti_wazuh_service_present | default(true))
