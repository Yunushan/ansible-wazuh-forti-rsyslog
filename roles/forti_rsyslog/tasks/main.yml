---
- name: Validate configuration - at least one protocol enabled
  ansible.builtin.assert:
    that:
      - forti_syslog_enable_udp or forti_syslog_enable_tcp
    fail_msg: >-
      Enable at least one protocol: forti_syslog_enable_udp and/or forti_syslog_enable_tcp.

- name: Validate retention days
  ansible.builtin.assert:
    that:
      - (forti_log_retention_days | int) > 0
    fail_msg: "forti_log_retention_days must be a positive integer (e.g., 14, 30, 60)."

- name: Validate tuning mode
  ansible.builtin.assert:
    that:
      - forti_tuning_mode is none or (forti_tuning_mode | string | lower | trim) in ["1", "2", "3", "source_filter", "split_traffic", "wazuh_light", "auto"]
    fail_msg: >-
      forti_tuning_mode must be one of: 1, 2, 3, source_filter, split_traffic, wazuh_light, auto.

- name: Determine tuning mode input
  ansible.builtin.set_fact:
    forti_tuning_mode_input: "{{ (forti_tuning_mode | default('1')) | string | lower | trim }}"
    forti_tuning_auto_enabled: "{{ (forti_tuning_mode is none) or ((forti_tuning_mode | string | lower | trim) == 'auto') }}"

- name: Determine tuning mode (auto)
  ansible.builtin.set_fact:
    forti_tuning_mode_auto: >-
      {{
        'split_traffic'
        if (forti_traffic_filebeat_manage is not none)
        else (
          'wazuh_light'
          if (
            forti_wazuh_manage_logall
            and forti_wazuh_manage_logall_json
            and (forti_wazuh_logall | string | lower | trim) in ['no', 'false', '0']
            and (forti_wazuh_logall_json | string | lower | trim) in ['no', 'false', '0']
          )
          else 'source_filter'
        )
      }}
  when: forti_tuning_auto_enabled

- name: Determine tuning mode effective
  ansible.builtin.set_fact:
    forti_tuning_mode_effective: >-
      {{
        forti_tuning_mode_auto
        if forti_tuning_auto_enabled
        else (
          'source_filter' if forti_tuning_mode_input in ['1', 'source_filter']
          else 'split_traffic' if forti_tuning_mode_input in ['2', 'split_traffic']
          else 'wazuh_light' if forti_tuning_mode_input in ['3', 'wazuh_light']
          else forti_tuning_mode_input
        )
      }}

- name: Report tuning mode auto selection
  ansible.builtin.debug:
    msg: "forti_tuning_mode auto selected '{{ forti_tuning_mode_effective }}'."
  when: forti_tuning_auto_enabled

- name: Set tuning flags
  ansible.builtin.set_fact:
    forti_tuning_source_filter: "{{ forti_tuning_mode_effective == 'source_filter' }}"
    forti_tuning_split_traffic: "{{ forti_tuning_mode_effective == 'split_traffic' }}"
    forti_tuning_wazuh_light: "{{ forti_tuning_mode_effective == 'wazuh_light' }}"
    forti_traffic_filebeat_manage_effective: >-
      {{
        forti_traffic_filebeat_manage
        if (forti_traffic_filebeat_manage is not none)
        else (forti_tuning_mode_effective == 'split_traffic')
      }}

- name: Determine Filebeat restart behavior
  ansible.builtin.set_fact:
    forti_filebeat_restart_effective: >-
      {{
        (forti_wazuh_filebeat_manage and (forti_wazuh_filebeat_restart | default(true)))
        or (forti_traffic_filebeat_manage_effective and (forti_traffic_filebeat_restart | default(true)))
      }}

- name: Validate traffic patterns for tuning mode
  ansible.builtin.assert:
    that:
      - forti_syslog_traffic_patterns | length > 0
    fail_msg: >-
      forti_syslog_traffic_patterns must be set when forti_tuning_mode is source_filter or split_traffic.
  when: forti_tuning_mode_effective in ["source_filter", "split_traffic"]

- name: Determine Wazuh logall settings for tuning mode
  ansible.builtin.set_fact:
    forti_wazuh_manage_logall_effective: >-
      {{ true if forti_tuning_wazuh_light else forti_wazuh_manage_logall }}
    forti_wazuh_logall_effective: >-
      {{ "no" if forti_tuning_wazuh_light else forti_wazuh_logall }}
    forti_wazuh_manage_logall_json_effective: >-
      {{ true if forti_tuning_wazuh_light else forti_wazuh_manage_logall_json }}
    forti_wazuh_logall_json_effective: >-
      {{ "no" if forti_tuning_wazuh_light else forti_wazuh_logall_json }}

- name: Detect Wazuh ruleset directories (auto Fortinet exclude)
  ansible.builtin.stat:
    path: "{{ item }}"
  register: forti_wazuh_ruleset_dir_stats
  loop: "{{ forti_wazuh_ruleset_dirs }}"
  when:
    - forti_wazuh_manage
    - forti_wazuh_ruleset_exclude_forti | bool

- name: Build Wazuh ruleset directories list (auto Fortinet exclude)
  ansible.builtin.set_fact:
    forti_wazuh_ruleset_dirs_effective: >-
      {{
        forti_wazuh_ruleset_dir_stats.results
        | selectattr('stat.exists', 'equalto', true)
        | map(attribute='item')
        | list
      }}
  when:
    - forti_wazuh_manage
    - forti_wazuh_ruleset_exclude_forti | bool

- name: Find Fortinet ruleset files (auto exclude)
  ansible.builtin.find:
    paths: "{{ forti_wazuh_ruleset_dirs_effective }}"
    patterns: "{{ forti_wazuh_ruleset_exclude_forti_patterns }}"
    file_type: file
  register: forti_wazuh_ruleset_forti_files
  when:
    - forti_wazuh_manage
    - forti_wazuh_ruleset_exclude_forti | bool
    - forti_wazuh_ruleset_dirs_effective | length > 0

- name: Build auto ruleset excludes (Fortinet)
  ansible.builtin.set_fact:
    forti_wazuh_ruleset_rule_excludes_auto: >-
      {{
        forti_wazuh_ruleset_forti_files.files
        | map(attribute='path')
        | map('regex_replace', '^' ~ forti_wazuh_root ~ '/', '')
        | list
      }}
  when:
    - forti_wazuh_manage
    - forti_wazuh_ruleset_exclude_forti | bool
    - forti_wazuh_ruleset_forti_files is defined

- name: Default auto ruleset excludes to empty
  ansible.builtin.set_fact:
    forti_wazuh_ruleset_rule_excludes_auto: []
  when:
    - forti_wazuh_manage
    - forti_wazuh_ruleset_exclude_forti | bool
    - forti_wazuh_ruleset_rule_excludes_auto is not defined

- name: Determine Wazuh ruleset exclude lists
  ansible.builtin.set_fact:
    forti_wazuh_ruleset_rule_excludes_effective: >-
      {{
        (forti_wazuh_ruleset_rule_excludes
        + (forti_wazuh_ruleset_rule_excludes_auto | default([])))
        | unique
      }}
    forti_wazuh_ruleset_decoder_excludes_effective: "{{ forti_wazuh_ruleset_decoder_excludes }}"

- name: Determine Wazuh manager tuning enablement
  ansible.builtin.set_fact:
    forti_wazuh_tuning_values_set: >-
      {{
        (forti_wazuh_disable_modules | length > 0) or
        (forti_wazuh_ruleset_rule_excludes_effective | length > 0) or
        (forti_wazuh_ruleset_decoder_excludes_effective | length > 0)
      }}
    forti_wazuh_tuning_manage_effective: >-
      {{
        (forti_wazuh_tuning_manage is not none)
        | ternary((forti_wazuh_tuning_manage | default(false, true)) | bool, (forti_wazuh_disable_modules | length > 0))
      }}
    forti_wazuh_ruleset_manage_effective: >-
      {{
        (forti_wazuh_ruleset_manage is not none)
        | ternary(
            (forti_wazuh_ruleset_manage | default(false, true)) | bool,
            (forti_wazuh_ruleset_rule_excludes_effective | length > 0)
            or (forti_wazuh_ruleset_decoder_excludes_effective | length > 0)
          )
      }}

- name: Validate Wazuh manager tuning values
  ansible.builtin.assert:
    that:
      - forti_wazuh_tuning_values_set or (not forti_wazuh_tuning_manage_effective | bool)
    fail_msg: "Wazuh tuning is enabled but no tuning values are set."

- name: Validate Wazuh ruleset tuning values
  ansible.builtin.assert:
    that:
      - (forti_wazuh_ruleset_rule_excludes_effective | length > 0)
        or (forti_wazuh_ruleset_decoder_excludes_effective | length > 0)
        or (not forti_wazuh_ruleset_manage_effective | bool)
    fail_msg: "Ruleset tuning is enabled but no rule/decoder excludes are set."

- name: Warn when Wazuh light mode disables archives
  ansible.builtin.debug:
    msg: >-
      forti_tuning_mode=wazuh_light disables logall/logall_json (archives).
      Alerts still work, but archives indices will be empty.
  when: forti_tuning_wazuh_light

- name: Validate archives severity mode
  ansible.builtin.assert:
    that:
      - (forti_wazuh_archives_severity_mode | default('') | lower | trim) in ["", "drop", "zero", "keep"]
    fail_msg: "forti_wazuh_archives_severity_mode must be one of: drop, zero, keep (or empty)."
  when:
    - forti_wazuh_manage
    - forti_wazuh_filebeat_manage or forti_wazuh_archives_pipeline_manage

- name: Validate OpenSearch API configuration
  ansible.builtin.assert:
    that:
      - forti_wazuh_opensearch_url | length > 0
      - forti_wazuh_opensearch_auth_method in ["basic", "token", "none"]
      - forti_wazuh_opensearch_auth_method != "basic" or (forti_wazuh_opensearch_username | length > 0 and forti_wazuh_opensearch_password | length > 0)
      - forti_wazuh_opensearch_auth_method != "token" or (forti_wazuh_opensearch_token | length > 0)
    fail_msg: >-
      OpenSearch API management is enabled but required settings are missing.
      Set forti_wazuh_opensearch_url and the appropriate auth variables
      (forti_wazuh_opensearch_username/password or forti_wazuh_opensearch_token),
      or set forti_wazuh_archives_pipeline_manage=false.
  when: forti_wazuh_archives_pipeline_manage

- name: Validate Wazuh archives retention days
  ansible.builtin.assert:
    that:
      - (forti_wazuh_archives_log_retention_days | int) > 0
    fail_msg: "forti_wazuh_archives_log_retention_days must be a positive integer (e.g., 7, 14, 30)."
  when: forti_wazuh_archives_logrotate_manage

- name: Validate UDP port
  ansible.builtin.assert:
    that:
      - (forti_syslog_udp_port | int) > 0
      - (forti_syslog_udp_port | int) < 65536
  when: forti_syslog_enable_udp

- name: Validate TCP port
  ansible.builtin.assert:
    that:
      - (forti_syslog_tcp_port | int) > 0
      - (forti_syslog_tcp_port | int) < 65536
  when: forti_syslog_enable_tcp

- name: Install rsyslog and logrotate
  ansible.builtin.package:
    name:
      - rsyslog
      - logrotate
    state: present

- name: Ensure Fortinet log directory exists
  ansible.builtin.file:
    path: "{{ forti_log_dir }}"
    state: directory
    owner: "{{ forti_log_owner }}"
    group: "{{ forti_log_group }}"
    mode: "{{ forti_log_dir_mode }}"

- name: Ensure Fortinet log file exists (so Wazuh can tail it immediately)
  ansible.builtin.file:
    path: "{{ forti_log_path }}"
    state: touch
    owner: "{{ forti_log_owner }}"
    group: "{{ forti_log_group }}"
    mode: "{{ forti_log_file_mode }}"

- name: Ensure Fortinet traffic log file exists (split mode)
  ansible.builtin.file:
    path: "{{ forti_traffic_log_path }}"
    state: touch
    owner: "{{ forti_traffic_log_owner }}"
    group: "{{ forti_traffic_log_group }}"
    mode: "{{ forti_traffic_log_mode }}"
  when: forti_tuning_split_traffic

- name: Deploy rsyslog configuration for Fortinet
  ansible.builtin.template:
    src: fortinet-rsyslog.conf.j2
    dest: "{{ forti_rsyslog_conf_path }}"
    owner: root
    group: root
    mode: "0644"
  notify: Restart rsyslog

- name: Deploy logrotate configuration for Fortinet logs
  ansible.builtin.template:
    src: fortinet-logrotate.conf.j2
    dest: "{{ forti_logrotate_conf_path }}"
    owner: root
    group: root
    mode: "0644"

- name: Deploy logrotate configuration for Wazuh archives
  ansible.builtin.template:
    src: wazuh-archives-logrotate.conf.j2
    dest: "{{ forti_wazuh_archives_logrotate_conf_path }}"
    owner: root
    group: root
    mode: "0644"
  when: forti_wazuh_archives_logrotate_manage

- name: Ensure rsyslog is enabled and started
  ansible.builtin.service:
    name: "{{ rsyslog_service_name }}"
    state: started
    enabled: true

# Apply pending rsyslog config changes before health checks.
- name: Flush rsyslog handlers before health checks
  ansible.builtin.meta: flush_handlers
  when: forti_rsyslog_healthcheck

- name: Wait briefly for rsyslog to bind listeners
  ansible.builtin.pause:
    seconds: "{{ forti_rsyslog_healthcheck_delay }}"
  when:
    - forti_rsyslog_healthcheck
    - (forti_rsyslog_healthcheck_delay | int) > 0

# --- rsyslog health checks ---
- name: Initialize rsyslog health check issues
  ansible.builtin.set_fact:
    forti_rsyslog_health_issues: []
  when: forti_rsyslog_healthcheck

- name: Gather service facts (rsyslog)
  ansible.builtin.service_facts:
  when: forti_rsyslog_healthcheck

- name: Determine rsyslog service facts key
  ansible.builtin.set_fact:
    forti_rsyslog_service_key: >-
      {{ rsyslog_service_name if (rsyslog_service_name in ansible_facts.services)
         else (rsyslog_service_name ~ '.service') if ((rsyslog_service_name ~ '.service') in ansible_facts.services)
         else '' }}
  when: forti_rsyslog_healthcheck

- name: Evaluate rsyslog service state
  ansible.builtin.set_fact:
    forti_rsyslog_service_running: >-
      {{ (forti_rsyslog_service_key != '') and
         (ansible_facts.services[forti_rsyslog_service_key].state == 'running') }}
  when: forti_rsyslog_healthcheck

- name: Flag rsyslog service not running
  ansible.builtin.set_fact:
    forti_rsyslog_health_issues: >-
      {{ forti_rsyslog_health_issues + ["rsyslog service '" ~ rsyslog_service_name ~ "' is not running or not detected."] }}
  when:
    - forti_rsyslog_healthcheck
    - not forti_rsyslog_service_running

- name: Check Fortinet log path
  ansible.builtin.stat:
    path: "{{ forti_log_path }}"
  register: forti_rsyslog_log_path_stat
  when: forti_rsyslog_healthcheck

- name: Flag missing Fortinet log path
  ansible.builtin.set_fact:
    forti_rsyslog_health_issues: >-
      {{ forti_rsyslog_health_issues + ["Fortinet log path '" ~ forti_log_path ~ "' does not exist."] }}
  when:
    - forti_rsyslog_healthcheck
    - not forti_rsyslog_log_path_stat.stat.exists

- name: Detect socket inspection tool
  ansible.builtin.shell: "command -v ss || command -v netstat"
  register: forti_rsyslog_sock_tool
  changed_when: false
  failed_when: false
  when:
    - forti_rsyslog_healthcheck
    - forti_syslog_enable_tcp or forti_syslog_enable_udp

- name: Flag missing socket inspection tool
  ansible.builtin.set_fact:
    forti_rsyslog_health_issues: >-
      {{ forti_rsyslog_health_issues + ['Unable to verify rsyslog ports because neither ss nor netstat is available.'] }}
  when:
    - forti_rsyslog_healthcheck
    - forti_syslog_enable_tcp or forti_syslog_enable_udp
    - forti_rsyslog_sock_tool.stdout | trim | length == 0

- name: Capture TCP listeners
  ansible.builtin.command: "{{ forti_rsyslog_sock_tool.stdout | trim }} -lnt"
  register: forti_rsyslog_tcp_listen
  changed_when: false
  failed_when: false
  when:
    - forti_rsyslog_healthcheck
    - forti_syslog_enable_tcp
    - forti_rsyslog_sock_tool.stdout | trim | length > 0

- name: Evaluate TCP listener
  ansible.builtin.set_fact:
    forti_rsyslog_tcp_listening: >-
      {{ (forti_rsyslog_tcp_listen.rc == 0) and
         ((forti_rsyslog_tcp_listen.stdout | regex_search(':' ~ (forti_syslog_tcp_port | string) ~ '(\\s|$)')) is not none) }}
  when:
    - forti_rsyslog_healthcheck
    - forti_syslog_enable_tcp
    - forti_rsyslog_sock_tool.stdout | trim | length > 0

- name: Recheck TCP listener with retries
  ansible.builtin.shell: |
    attempts={{ forti_rsyslog_healthcheck_retries | int }}
    delay={{ forti_rsyslog_healthcheck_retry_delay | int }}
    i=0
    while [ $i -lt "$attempts" ]; do
      {{ forti_rsyslog_sock_tool.stdout | trim }} -lnt | grep -Eq ":{{ forti_syslog_tcp_port | string }}([[:space:]]|$)" && exit 0
      i=$((i+1))
      sleep "$delay"
    done
    exit 1
  register: forti_rsyslog_tcp_recheck
  changed_when: false
  failed_when: false
  when:
    - forti_rsyslog_healthcheck
    - forti_syslog_enable_tcp
    - forti_rsyslog_sock_tool.stdout | trim | length > 0
    - not forti_rsyslog_tcp_listening

- name: Update TCP listener status after retry
  ansible.builtin.set_fact:
    forti_rsyslog_tcp_listening: >-
      {{ forti_rsyslog_tcp_listening or (forti_rsyslog_tcp_recheck.rc == 0) }}
  when:
    - forti_rsyslog_healthcheck
    - forti_syslog_enable_tcp
    - forti_rsyslog_sock_tool.stdout | trim | length > 0
    - not forti_rsyslog_tcp_listening

- name: Flag TCP port not listening
  ansible.builtin.set_fact:
    forti_rsyslog_health_issues: >-
      {{ forti_rsyslog_health_issues + ['rsyslog TCP port ' ~ (forti_syslog_tcp_port | string) ~ ' is not listening.'] }}
  when:
    - forti_rsyslog_healthcheck
    - forti_syslog_enable_tcp
    - forti_rsyslog_sock_tool.stdout | trim | length > 0
    - not forti_rsyslog_tcp_listening

- name: Capture UDP listeners
  ansible.builtin.command: "{{ forti_rsyslog_sock_tool.stdout | trim }} -lnu"
  register: forti_rsyslog_udp_listen
  changed_when: false
  failed_when: false
  when:
    - forti_rsyslog_healthcheck
    - forti_syslog_enable_udp
    - forti_rsyslog_sock_tool.stdout | trim | length > 0

- name: Evaluate UDP listener
  ansible.builtin.set_fact:
    forti_rsyslog_udp_listening: >-
      {{ (forti_rsyslog_udp_listen.rc == 0) and
         ((forti_rsyslog_udp_listen.stdout | regex_search(':' ~ (forti_syslog_udp_port | string) ~ '(\\s|$)')) is not none) }}
  when:
    - forti_rsyslog_healthcheck
    - forti_syslog_enable_udp
    - forti_rsyslog_sock_tool.stdout | trim | length > 0

- name: Recheck UDP listener with retries
  ansible.builtin.shell: |
    attempts={{ forti_rsyslog_healthcheck_retries | int }}
    delay={{ forti_rsyslog_healthcheck_retry_delay | int }}
    i=0
    while [ $i -lt "$attempts" ]; do
      {{ forti_rsyslog_sock_tool.stdout | trim }} -lnu | grep -Eq ":{{ forti_syslog_udp_port | string }}([[:space:]]|$)" && exit 0
      i=$((i+1))
      sleep "$delay"
    done
    exit 1
  register: forti_rsyslog_udp_recheck
  changed_when: false
  failed_when: false
  when:
    - forti_rsyslog_healthcheck
    - forti_syslog_enable_udp
    - forti_rsyslog_sock_tool.stdout | trim | length > 0
    - not forti_rsyslog_udp_listening

- name: Update UDP listener status after retry
  ansible.builtin.set_fact:
    forti_rsyslog_udp_listening: >-
      {{ forti_rsyslog_udp_listening or (forti_rsyslog_udp_recheck.rc == 0) }}
  when:
    - forti_rsyslog_healthcheck
    - forti_syslog_enable_udp
    - forti_rsyslog_sock_tool.stdout | trim | length > 0
    - not forti_rsyslog_udp_listening

- name: Flag UDP port not listening
  ansible.builtin.set_fact:
    forti_rsyslog_health_issues: >-
      {{ forti_rsyslog_health_issues + ['rsyslog UDP port ' ~ (forti_syslog_udp_port | string) ~ ' is not listening.'] }}
  when:
    - forti_rsyslog_healthcheck
    - forti_syslog_enable_udp
    - forti_rsyslog_sock_tool.stdout | trim | length > 0
    - not forti_rsyslog_udp_listening

- name: Fail if rsyslog health checks failed
  ansible.builtin.fail:
    msg: |-
      rsyslog is not working in Ansible:
      - {{ forti_rsyslog_health_issues | join('\n- ') }}
  when:
    - forti_rsyslog_healthcheck
    - forti_rsyslog_healthcheck_fail
    - forti_rsyslog_health_issues | length > 0

- name: Warn if rsyslog health checks failed
  ansible.builtin.debug:
    msg: |-
      rsyslog is not working in Ansible:
      - {{ forti_rsyslog_health_issues | join('\n- ') }}
  when:
    - forti_rsyslog_healthcheck
    - not forti_rsyslog_healthcheck_fail
    - forti_rsyslog_health_issues | length > 0

# --- Wazuh integration ---
- name: Check for Wazuh ossec.conf
  ansible.builtin.stat:
    path: "{{ forti_wazuh_ossec_conf_path }}"
  register: wazuh_ossec_conf
  when: forti_wazuh_manage

- name: Fail if Wazuh ossec.conf does not exist
  ansible.builtin.fail:
    msg: >-
      Wazuh config not found at {{ forti_wazuh_ossec_conf_path }}.
      Set forti_wazuh_ossec_conf_path to the correct ossec.conf location
      or set forti_wazuh_manage=false to configure rsyslog only.
  when:
    - forti_wazuh_manage
    - forti_wazuh_fail_if_missing
    - not wazuh_ossec_conf.stat.exists

- name: Ensure Wazuh logall is configured (ossec.conf)
  ansible.builtin.lineinfile:
    path: "{{ forti_wazuh_ossec_conf_path }}"
    regexp: '^\s*<logall>.*</logall>'
    line: "  <logall>{{ forti_wazuh_logall_effective }}</logall>"
    insertafter: '^\s*<global>'
  when:
    - forti_wazuh_manage
    - wazuh_ossec_conf.stat.exists
    - forti_wazuh_manage_logall_effective
  notify: Restart wazuh-manager

- name: Ensure Wazuh logall_json is configured (ossec.conf)
  ansible.builtin.lineinfile:
    path: "{{ forti_wazuh_ossec_conf_path }}"
    regexp: '^\s*<logall_json>.*</logall_json>'
    line: "  <logall_json>{{ forti_wazuh_logall_json_effective }}</logall_json>"
    insertafter: '^\s*<global>'
  when:
    - forti_wazuh_manage
    - wazuh_ossec_conf.stat.exists
    - forti_wazuh_manage_logall_json_effective
  notify: Restart wazuh-manager

- name: Check for Wazuh ruleset block
  ansible.builtin.command: "grep -Eq '^\\s*<ruleset>' {{ forti_wazuh_ossec_conf_path }}"
  register: forti_wazuh_ruleset_present
  changed_when: false
  failed_when: false
  when:
    - forti_wazuh_manage
    - wazuh_ossec_conf.stat.exists
    - forti_wazuh_ruleset_manage_effective

- name: Tune Wazuh ruleset in existing block
  ansible.builtin.blockinfile:
    path: "{{ forti_wazuh_ossec_conf_path }}"
    marker: "<!-- {mark} ANSIBLE MANAGED FORTI WAZUH RULE TUNING -->"
    insertafter: '^\s*<ruleset>'
    block: |2
      {%- for rule_id in forti_wazuh_ruleset_rule_excludes_effective %}
      <rule_exclude>{{ rule_id }}</rule_exclude>
      {%- endfor %}
      {%- for decoder_name in forti_wazuh_ruleset_decoder_excludes_effective %}
      <decoder_exclude>{{ decoder_name }}</decoder_exclude>
      {%- endfor %}
  when:
    - forti_wazuh_manage
    - wazuh_ossec_conf.stat.exists
    - forti_wazuh_ruleset_manage_effective
    - forti_wazuh_ruleset_present.rc == 0
  notify: Restart wazuh-manager

- name: Add Wazuh ruleset block for tuning
  ansible.builtin.blockinfile:
    path: "{{ forti_wazuh_ossec_conf_path }}"
    marker: "<!-- {mark} ANSIBLE MANAGED FORTI WAZUH RULESET -->"
    insertbefore: "{{ forti_wazuh_insert_before_regex }}"
    block: |2
      <ruleset>
      {%- for rule_id in forti_wazuh_ruleset_rule_excludes_effective %}
        <rule_exclude>{{ rule_id }}</rule_exclude>
      {%- endfor %}
      {%- for decoder_name in forti_wazuh_ruleset_decoder_excludes_effective %}
        <decoder_exclude>{{ decoder_name }}</decoder_exclude>
      {%- endfor %}
      </ruleset>
  when:
    - forti_wazuh_manage
    - wazuh_ossec_conf.stat.exists
    - forti_wazuh_ruleset_manage_effective
    - forti_wazuh_ruleset_present.rc != 0
  notify: Restart wazuh-manager

- name: Check for Wazuh module blocks to disable
  ansible.builtin.command: "grep -Eq '<wodle[^>]*name=\"{{ item }}\"' {{ forti_wazuh_ossec_conf_path }}"
  register: forti_wazuh_wodle_present
  changed_when: false
  failed_when: false
  loop: "{{ forti_wazuh_disable_modules }}"
  when:
    - forti_wazuh_manage
    - wazuh_ossec_conf.stat.exists
    - forti_wazuh_tuning_manage_effective
    - forti_wazuh_disable_modules | length > 0

- name: Disable Wazuh modules in existing wodle blocks
  ansible.builtin.replace:
    path: "{{ forti_wazuh_ossec_conf_path }}"
    regexp: '(?ms)(<wodle\\s+name="{{ item.item }}"[^>]*>.*?<disabled>)([^<]*)(</disabled>)'
    replace: '\1yes\3'
  loop: "{{ forti_wazuh_wodle_present.results | default([]) }}"
  when:
    - forti_wazuh_manage
    - wazuh_ossec_conf.stat.exists
    - forti_wazuh_tuning_manage_effective
    - item.rc == 0
  notify: Restart wazuh-manager

- name: Add disabled flag to wodle blocks missing it
  ansible.builtin.replace:
    path: "{{ forti_wazuh_ossec_conf_path }}"
    regexp: '(?ms)(<wodle\\s+name="{{ item.item }}"[^>]*>)(?!.*?<disabled>)(.*?)</wodle>'
    replace: '\1\n  <disabled>yes</disabled>\2</wodle>'
  loop: "{{ forti_wazuh_wodle_present.results | default([]) }}"
  when:
    - forti_wazuh_manage
    - wazuh_ossec_conf.stat.exists
    - forti_wazuh_tuning_manage_effective
    - item.rc == 0
  notify: Restart wazuh-manager

- name: Add Wazuh module disable blocks when missing
  ansible.builtin.blockinfile:
    path: "{{ forti_wazuh_ossec_conf_path }}"
    marker: "<!-- {mark} ANSIBLE MANAGED FORTI WAZUH MODULE {{ item.item }} -->"
    insertbefore: "{{ forti_wazuh_insert_before_regex }}"
    block: |2
      <wodle name="{{ item.item }}">
        <disabled>yes</disabled>
      </wodle>
  loop: "{{ forti_wazuh_wodle_present.results | default([]) }}"
  when:
    - forti_wazuh_manage
    - wazuh_ossec_conf.stat.exists
    - forti_wazuh_tuning_manage_effective
    - item.rc != 0
  notify: Restart wazuh-manager

- name: Check for Filebeat Wazuh module config
  ansible.builtin.stat:
    path: "{{ forti_wazuh_filebeat_module_path }}"
  register: forti_wazuh_filebeat_module
  when:
    - forti_wazuh_manage
    - forti_wazuh_filebeat_manage

- name: Check for Filebeat config
  ansible.builtin.stat:
    path: "{{ forti_wazuh_filebeat_config_path }}"
  register: forti_wazuh_filebeat_config
  when:
    - forti_wazuh_manage
    - forti_wazuh_filebeat_manage

- name: Build Filebeat archives processors
  ansible.builtin.set_fact:
    forti_wazuh_archives_severity_mode_effective: >-
      {{
        (forti_wazuh_archives_severity_mode | default('') | lower | trim)
        if (forti_wazuh_archives_severity_mode | default('') | trim | length > 0)
        else (
          (forti_wazuh_archives_include_severity is defined and forti_wazuh_archives_include_severity is not none)
          | ternary(
              (forti_wazuh_archives_include_severity | default(false, true) | bool) | ternary('keep', 'drop'),
              (forti_wazuh_archives_clear_severity | default(true, true) | bool) | ternary('drop', 'keep')
            )
        )
      }}
  when:
    - forti_wazuh_manage
    - forti_wazuh_filebeat_manage

- name: Build Filebeat archives processors list
  ansible.builtin.set_fact:
    forti_wazuh_archives_processors: >-
      {{
        [] if (forti_wazuh_archives_severity_mode_effective == 'keep')
        else (
          (forti_wazuh_archives_severity_mode_effective == 'zero')
          | ternary(
              [
                {'drop_fields': {'fields': ['rule.level'], 'ignore_missing': true}},
                {'add_fields': {'target': 'rule', 'fields': {'level': 0}}}
              ],
              [{'drop_fields': {'fields': ['rule.level'], 'ignore_missing': true}}]
            )
        )
      }}
  when:
    - forti_wazuh_manage
    - forti_wazuh_filebeat_manage

- name: Warn if Filebeat config is missing
  ansible.builtin.debug:
    msg: >-
      Filebeat config not found at {{ forti_wazuh_filebeat_config_path }}.
      Archives shipping configuration may be skipped.
  when:
    - forti_wazuh_manage
    - forti_wazuh_filebeat_manage
    - not forti_wazuh_filebeat_config.stat.exists

- name: Check for Wazuh module in Filebeat config
  ansible.builtin.command: "grep -Eq '^[[:space:]]*- module:\\s*wazuh\\s*$' {{ forti_wazuh_filebeat_config_path }}"
  register: forti_wazuh_filebeat_module_inline
  changed_when: false
  failed_when: false
  when:
    - forti_wazuh_manage
    - forti_wazuh_filebeat_manage
    - forti_wazuh_filebeat_config.stat.exists

- name: Determine if inline Wazuh module exists
  ansible.builtin.set_fact:
    forti_wazuh_filebeat_module_inline_present: "{{ forti_wazuh_filebeat_module_inline.rc == 0 }}"
  when:
    - forti_wazuh_manage
    - forti_wazuh_filebeat_manage
    - forti_wazuh_filebeat_config.stat.exists

- name: Remove archives input file when inline module is used
  ansible.builtin.file:
    path: "{{ forti_wazuh_filebeat_inputs_file }}"
    state: absent
  when:
    - forti_wazuh_manage
    - forti_wazuh_filebeat_manage
    - forti_wazuh_filebeat_inputs_manage
    - forti_wazuh_filebeat_config.stat.exists
    - not forti_wazuh_filebeat_module.stat.exists
    - forti_wazuh_filebeat_module_inline_present | default(false)

- name: Warn if Filebeat Wazuh module config is missing
  ansible.builtin.debug:
    msg: >-
      Filebeat Wazuh module config not found at {{ forti_wazuh_filebeat_module_path }}.
      Falling back to filebeat.inputs if enabled.
  when:
    - forti_wazuh_manage
    - forti_wazuh_filebeat_manage
    - not forti_wazuh_filebeat_module.stat.exists
    - not (forti_wazuh_filebeat_module_inline_present | default(false))

- name: Remove legacy archives input block from filebeat.yml
  ansible.builtin.blockinfile:
    path: "{{ forti_wazuh_filebeat_config_path }}"
    marker: "# {mark} ANSIBLE MANAGED FORTI WAZUH ARCHIVES INPUT"
    state: absent
  when:
    - forti_wazuh_manage
    - forti_wazuh_filebeat_manage
    - forti_wazuh_filebeat_inputs_manage
    - forti_wazuh_filebeat_config.stat.exists
    - not forti_wazuh_filebeat_module.stat.exists
    - not (forti_wazuh_filebeat_module_inline_present | default(false))

- name: Ensure Filebeat inputs directory exists
  ansible.builtin.file:
    path: "{{ forti_wazuh_filebeat_inputs_dir }}"
    state: directory
    owner: root
    group: root
    mode: "0755"
  when:
    - forti_wazuh_manage
    - forti_wazuh_filebeat_manage
    - forti_wazuh_filebeat_inputs_manage
    - forti_wazuh_filebeat_config.stat.exists
    - not forti_wazuh_filebeat_module.stat.exists
    - not (forti_wazuh_filebeat_module_inline_present | default(false))

- name: Ensure filebeat.config.inputs is configured
  ansible.builtin.blockinfile:
    path: "{{ forti_wazuh_filebeat_config_path }}"
    marker: "# {mark} ANSIBLE MANAGED FORTI WAZUH INPUTS CONFIG"
    block: |
      filebeat.config.inputs:
        enabled: true
        path: {{ forti_wazuh_filebeat_inputs_glob }}
        reload.enabled: {{ "true" if forti_wazuh_filebeat_inputs_reload else "false" }}
  when:
    - forti_wazuh_manage
    - forti_wazuh_filebeat_manage
    - forti_wazuh_filebeat_inputs_manage
    - forti_wazuh_filebeat_config.stat.exists
    - not forti_wazuh_filebeat_module.stat.exists
    - not (forti_wazuh_filebeat_module_inline_present | default(false))
  notify: Restart filebeat

- name: Write Wazuh archives Filebeat input
  ansible.builtin.copy:
    dest: "{{ forti_wazuh_filebeat_inputs_file }}"
    owner: root
    group: root
    mode: "0644"
    content: |
      {{ [
          {
            'type': forti_wazuh_filebeat_input_type,
            'enabled': (forti_wazuh_filebeat_archives_enabled | bool),
            'paths': forti_wazuh_filebeat_archives_paths
          }
          | combine(
              (forti_wazuh_archives_processors | length > 0)
              | ternary({'processors': forti_wazuh_archives_processors}, {})
            )
        ] | to_nice_yaml(indent=2) }}
  when:
    - forti_wazuh_manage
    - forti_wazuh_filebeat_manage
    - forti_wazuh_filebeat_inputs_manage
    - forti_wazuh_filebeat_config.stat.exists
    - not forti_wazuh_filebeat_module.stat.exists
    - not (forti_wazuh_filebeat_module_inline_present | default(false))
  notify: Restart filebeat

- name: Remove existing archives block in Filebeat Wazuh module config
  ansible.builtin.replace:
    path: "{{ forti_wazuh_filebeat_module_path }}"
    regexp: '(?ms)^([ \t]*- module:\s*wazuh\s*\n(?:^[ \t]+.*\n)*?)^[ \t]{2}archives:\s*\n(?:^[ \t]{4,}.*\n)*'
    replace: '\1'
  when:
    - forti_wazuh_manage
    - forti_wazuh_filebeat_manage
    - forti_wazuh_filebeat_module.stat.exists
  notify: Restart filebeat

- name: Check for archives block in Filebeat Wazuh module config
  ansible.builtin.command: "grep -Eq '^[[:space:]]*archives:' {{ forti_wazuh_filebeat_module_path }}"
  register: forti_wazuh_filebeat_archives_block
  changed_when: false
  failed_when: false
  when:
    - forti_wazuh_manage
    - forti_wazuh_filebeat_manage
    - forti_wazuh_filebeat_module.stat.exists

- name: Update archives enabled in Filebeat Wazuh module config
  ansible.builtin.replace:
    path: "{{ forti_wazuh_filebeat_module_path }}"
    regexp: '(?ms)^([ \t]*archives:\s*\n(?:^[ \t]+.*\n)*?^[ \t]+enabled:\s*)(true|false)'
    replace: '\1{{ "true" if forti_wazuh_filebeat_archives_enabled else "false" }}'
  when:
    - forti_wazuh_manage
    - forti_wazuh_filebeat_manage
    - forti_wazuh_filebeat_module.stat.exists
    - forti_wazuh_filebeat_archives_block.rc == 0
  notify: Restart filebeat

- name: Insert archives block in Filebeat Wazuh module config
  ansible.builtin.blockinfile:
    path: "{{ forti_wazuh_filebeat_module_path }}"
    marker: "# {mark} ANSIBLE MANAGED FORTI WAZUH ARCHIVES"
    insertafter: '^\s*- module:\s*wazuh\s*$'
    block: >-
      {{
        {
          'archives': (
            {
              'enabled': (forti_wazuh_filebeat_archives_enabled | bool),
              'var.paths': forti_wazuh_filebeat_archives_paths
            }
            | combine(
                (forti_wazuh_archives_processors | length > 0)
                | ternary({'processors': forti_wazuh_archives_processors}, {})
              )
          )
        } | to_nice_yaml(indent=2) | indent(2, true)
      }}
  when:
    - forti_wazuh_manage
    - forti_wazuh_filebeat_manage
    - forti_wazuh_filebeat_module.stat.exists
    - forti_wazuh_filebeat_archives_block.rc != 0
  notify: Restart filebeat

- name: Remove existing archives block in Filebeat config (inline module)
  ansible.builtin.replace:
    path: "{{ forti_wazuh_filebeat_config_path }}"
    regexp: '(?ms)^([ \t]*- module:\s*wazuh\s*\n(?:^[ \t]+.*\n)*?)^[ \t]{4}archives:\s*\n(?:^[ \t]{6,}.*\n)*'
    replace: '\1'
  when:
    - forti_wazuh_manage
    - forti_wazuh_filebeat_manage
    - forti_wazuh_filebeat_config.stat.exists
    - not forti_wazuh_filebeat_module.stat.exists
    - forti_wazuh_filebeat_module_inline_present | default(false)
  notify: Restart filebeat

- name: Remove inline archives block without paths
  ansible.builtin.replace:
    path: "{{ forti_wazuh_filebeat_config_path }}"
    regexp: '(?ms)^[ \t]{4}archives:\s*\n^[ \t]{6}enabled:\s*(true|false)\s*\n(?!^[ \t]{6}var\.paths:)'
    replace: ''
  when:
    - forti_wazuh_manage
    - forti_wazuh_filebeat_manage
    - forti_wazuh_filebeat_config.stat.exists
    - not forti_wazuh_filebeat_module.stat.exists
    - forti_wazuh_filebeat_module_inline_present | default(false)
  notify: Restart filebeat

- name: Ensure archives block in Filebeat config (inline module)
  ansible.builtin.blockinfile:
    path: "{{ forti_wazuh_filebeat_config_path }}"
    marker: "# {mark} ANSIBLE MANAGED FORTI WAZUH ARCHIVES INLINE"
    insertafter: '^\s*- module:\s*wazuh\s*$'
    block: >-
      {{
        {
          'archives': (
            {
              'enabled': (forti_wazuh_filebeat_archives_enabled | bool),
              'var.paths': forti_wazuh_filebeat_archives_paths
            }
            | combine(
                (forti_wazuh_archives_processors | length > 0)
                | ternary({'processors': forti_wazuh_archives_processors}, {})
              )
          )
        } | to_nice_yaml(indent=2) | indent(4, true)
      }}
  when:
    - forti_wazuh_manage
    - forti_wazuh_filebeat_manage
    - forti_wazuh_filebeat_config.stat.exists
    - not forti_wazuh_filebeat_module.stat.exists
    - forti_wazuh_filebeat_module_inline_present | default(false)
  notify: Restart filebeat

- name: Check for Filebeat config (traffic)
  ansible.builtin.stat:
    path: "{{ forti_traffic_filebeat_config_path }}"
  register: forti_traffic_filebeat_config
  when: forti_traffic_filebeat_manage_effective | bool

- name: Warn if Filebeat config is missing (traffic)
  ansible.builtin.debug:
    msg: >-
      Filebeat config not found at {{ forti_traffic_filebeat_config_path }}.
      Fortinet traffic shipping may be skipped.
  when:
    - forti_traffic_filebeat_manage_effective | bool
    - not forti_traffic_filebeat_config.stat.exists

- name: Check for filebeat.config.inputs in Filebeat config (traffic)
  ansible.builtin.command: "grep -Eq '^filebeat\\.config\\.inputs:' {{ forti_traffic_filebeat_config_path }}"
  register: forti_traffic_filebeat_inputs_block
  changed_when: false
  failed_when: false
  when:
    - forti_traffic_filebeat_manage_effective | bool
    - forti_traffic_filebeat_inputs_manage
    - forti_traffic_filebeat_config.stat.exists

- name: Ensure Filebeat inputs directory exists (traffic)
  ansible.builtin.file:
    path: "{{ forti_traffic_filebeat_inputs_dir }}"
    state: directory
    owner: root
    group: root
    mode: "0755"
  when:
    - forti_traffic_filebeat_manage_effective | bool
    - forti_traffic_filebeat_inputs_manage
    - forti_traffic_filebeat_config.stat.exists

- name: Ensure filebeat.config.inputs is configured (traffic)
  ansible.builtin.blockinfile:
    path: "{{ forti_traffic_filebeat_config_path }}"
    marker: "# {mark} ANSIBLE MANAGED FORTI TRAFFIC INPUTS CONFIG"
    block: |
      filebeat.config.inputs:
        enabled: true
        path: {{ forti_traffic_filebeat_inputs_glob }}
        reload.enabled: {{ "true" if forti_traffic_filebeat_inputs_reload else "false" }}
  when:
    - forti_traffic_filebeat_manage_effective | bool
    - forti_traffic_filebeat_inputs_manage
    - forti_traffic_filebeat_config.stat.exists
    - forti_traffic_filebeat_inputs_block.rc != 0
  notify: Restart filebeat

- name: Write Fortinet traffic Filebeat input
  ansible.builtin.copy:
    dest: "{{ forti_traffic_filebeat_inputs_file }}"
    owner: root
    group: root
    mode: "0644"
    content: |
      {{ [
          {
            'type': forti_traffic_filebeat_input_type,
            'enabled': (forti_traffic_filebeat_enabled | bool),
            'paths': [forti_traffic_log_path],
            'tags': forti_traffic_filebeat_tags,
            'fields_under_root': (forti_traffic_filebeat_fields_under_root | bool),
            'fields': forti_traffic_filebeat_fields
          }
        ] | to_nice_yaml(indent=2) }}
  when:
    - forti_traffic_filebeat_manage_effective | bool
    - forti_traffic_filebeat_inputs_manage
    - forti_traffic_filebeat_config.stat.exists
  notify: Restart filebeat

- name: Remove Fortinet traffic Filebeat input when disabled
  ansible.builtin.file:
    path: "{{ forti_traffic_filebeat_inputs_file }}"
    state: absent
  when:
    - not (forti_traffic_filebeat_manage_effective | bool)
    - forti_traffic_filebeat_inputs_manage

- name: Gather service facts (filebeat)
  ansible.builtin.service_facts:
  when:
    - forti_wazuh_manage
    - forti_wazuh_filebeat_manage
    - forti_wazuh_filebeat_module.stat.exists or forti_wazuh_filebeat_config.stat.exists

- name: Determine if Filebeat service exists
  ansible.builtin.set_fact:
    forti_filebeat_service_present: "{{ forti_filebeat_service_name in ansible_facts.services }}"
  when:
    - forti_wazuh_manage
    - forti_wazuh_filebeat_manage
    - forti_wazuh_filebeat_module.stat.exists or forti_wazuh_filebeat_config.stat.exists

- name: Gather service facts (filebeat - traffic)
  ansible.builtin.service_facts:
  when:
    - forti_traffic_filebeat_manage_effective | bool
    - forti_traffic_filebeat_config.stat.exists

- name: Determine if Filebeat service exists (traffic)
  ansible.builtin.set_fact:
    forti_filebeat_service_present: "{{ forti_filebeat_service_name in ansible_facts.services }}"
  when:
    - forti_traffic_filebeat_manage_effective | bool
    - forti_traffic_filebeat_config.stat.exists

- name: Gather service facts (for safe Wazuh restarts)
  ansible.builtin.service_facts:
  when:
    - forti_wazuh_manage
    - wazuh_ossec_conf.stat.exists

- name: Determine if Wazuh manager service exists
  ansible.builtin.set_fact:
    forti_wazuh_service_present: "{{ forti_wazuh_manager_service_name in ansible_facts.services }}"
  when:
    - forti_wazuh_manage
    - wazuh_ossec_conf.stat.exists

- name: Add Fortinet localfile entry to Wazuh (ossec.conf)
  ansible.builtin.blockinfile:
    path: "{{ forti_wazuh_ossec_conf_path }}"
    marker: "<!-- {mark} ANSIBLE MANAGED FORTI SYSLOG -->"
    insertbefore: "{{ forti_wazuh_insert_before_regex }}"
    block: |2
      <localfile>
        <location>{{ forti_log_path }}</location>
        <log_format>{{ forti_wazuh_log_format }}</log_format>
      </localfile>
  when:
    - forti_wazuh_manage
    - wazuh_ossec_conf.stat.exists
  notify: Restart wazuh-manager

- name: Determine backfill enablement
  ansible.builtin.set_fact:
    forti_backfill_values_set: >-
      {{
        (forti_backfill_source_path | length > 0) | int
        + (forti_backfill_output_path | length > 0) | int
        + (forti_backfill_start | length > 0) | int
        + (forti_backfill_end | length > 0) | int
      }}
    forti_backfill_enable_effective: >-
      {{
        (forti_backfill_enable is not none)
        | ternary(
            (forti_backfill_enable | default(false, true)) | bool,
            (forti_backfill_source_path | length > 0)
            and (forti_backfill_output_path | length > 0)
            and (forti_backfill_start | length > 0)
            and (forti_backfill_end | length > 0)
          )
      }}

- name: Validate backfill values completeness
  ansible.builtin.assert:
    that:
      - forti_backfill_values_set == 0 or forti_backfill_values_set == 4
    fail_msg: >-
      Backfill requires all of forti_backfill_source_path, forti_backfill_output_path,
      forti_backfill_start, and forti_backfill_end (or set none).

- name: Validate backfill settings
  ansible.builtin.assert:
    that:
      - forti_backfill_source_path | length > 0
      - forti_backfill_output_path | length > 0
      - forti_backfill_start | length > 0
      - forti_backfill_end | length > 0
    fail_msg: >-
      Backfill requires forti_backfill_source_path, forti_backfill_output_path,
      forti_backfill_start, and forti_backfill_end.
  when: forti_backfill_enable_effective

- name: Check backfill source log
  ansible.builtin.stat:
    path: "{{ forti_backfill_source_path }}"
  register: forti_backfill_source_stat
  when: forti_backfill_enable_effective

- name: Fail if backfill source log is missing
  ansible.builtin.assert:
    that:
      - forti_backfill_source_stat.stat.exists
    fail_msg: "Backfill source log not found at {{ forti_backfill_source_path }}."
  when: forti_backfill_enable_effective

- name: Ensure backfill output directory exists
  ansible.builtin.file:
    path: "{{ forti_backfill_output_path | dirname }}"
    state: directory
    owner: "{{ forti_backfill_owner }}"
    group: "{{ forti_backfill_group }}"
    mode: "{{ forti_log_dir_mode }}"
  when: forti_backfill_enable_effective

- name: Build backfill file
  ansible.builtin.shell: |
    awk -v start="{{ forti_backfill_start }}" -v end="{{ forti_backfill_end }}" '
      match($0,/date=([0-9-]+)/,d) && match($0,/time=([0-9:]+)/,t) {
        ts=d[1]" "t[1];
        if (ts >= start && ts < end) print;
      }' "{{ forti_backfill_source_path }}" > "{{ forti_backfill_output_path }}"
  args:
    creates: "{{ (forti_backfill_force | bool) | ternary(omit, forti_backfill_output_path) }}"
  when: forti_backfill_enable_effective

- name: Set backfill file permissions
  ansible.builtin.file:
    path: "{{ forti_backfill_output_path }}"
    state: file
    owner: "{{ forti_backfill_owner }}"
    group: "{{ forti_backfill_group }}"
    mode: "{{ forti_backfill_mode }}"
  when: forti_backfill_enable_effective

- name: Validate backfill localfile settings
  ansible.builtin.assert:
    that:
      - forti_wazuh_manage
      - wazuh_ossec_conf.stat.exists
    fail_msg: "Backfill localfile management requires Wazuh and ossec.conf."
  when:
    - forti_backfill_enable_effective
    - forti_backfill_manage_localfile

- name: Add Fortinet backfill localfile entry to Wazuh (ossec.conf)
  ansible.builtin.blockinfile:
    path: "{{ forti_wazuh_ossec_conf_path }}"
    marker: "<!-- {mark} ANSIBLE MANAGED FORTI BACKFILL -->"
    insertbefore: "{{ forti_wazuh_insert_before_regex }}"
    block: |2
      <localfile>
        <location>{{ forti_backfill_output_path }}</location>
        <log_format>{{ forti_backfill_log_format }}</log_format>
      </localfile>
  when:
    - forti_backfill_enable_effective
    - forti_backfill_manage_localfile
    - forti_wazuh_manage
    - wazuh_ossec_conf.stat.exists
  notify: Restart wazuh-manager

- name: Validate backfill cleanup settings
  ansible.builtin.assert:
    that:
      - forti_backfill_output_path | length > 0
    fail_msg: "Backfill cleanup requires forti_backfill_output_path."
  when: forti_backfill_cleanup_file | bool

- name: Remove Fortinet backfill localfile entry (cleanup)
  ansible.builtin.blockinfile:
    path: "{{ forti_wazuh_ossec_conf_path }}"
    marker: "<!-- {mark} ANSIBLE MANAGED FORTI BACKFILL -->"
    state: absent
  when:
    - forti_backfill_cleanup_localfile | bool
    - forti_wazuh_manage
    - wazuh_ossec_conf.stat.exists
  notify: Restart wazuh-manager

- name: Remove backfill file (cleanup)
  ansible.builtin.file:
    path: "{{ forti_backfill_output_path }}"
    state: absent
  when: forti_backfill_cleanup_file | bool

- name: Warn if Wazuh service was not detected (restart skipped)
  ansible.builtin.debug:
    msg: >-
      Wazuh manager service '{{ forti_wazuh_manager_service_name }}' was not found via service_facts.
      ossec.conf was updated, but automatic restart was skipped. Restart Wazuh manually or set the correct
      forti_wazuh_manager_service_name.
  when:
    - forti_wazuh_manage
    - wazuh_ossec_conf.stat.exists
    - not (forti_wazuh_service_present | default(true))

# --- Wazuh archives ingest pipeline (optional) ---
- name: Normalize OpenSearch URL
  ansible.builtin.set_fact:
    forti_wazuh_opensearch_url_base: "{{ forti_wazuh_opensearch_url | regex_replace('/+$', '') }}"
  when: forti_wazuh_archives_pipeline_manage

- name: Build OpenSearch request headers
  ansible.builtin.set_fact:
    forti_wazuh_opensearch_headers: >-
      {{
        {"Content-Type": "application/json"}
        | combine(
            (forti_wazuh_opensearch_auth_method == "token")
            | ternary({"Authorization": "Bearer " ~ forti_wazuh_opensearch_token}, {})
          )
      }}
  when: forti_wazuh_archives_pipeline_manage
  no_log: true

- name: Fetch ingest pipelines list
  ansible.builtin.uri:
    url: "{{ forti_wazuh_opensearch_url_base }}/_ingest/pipeline"
    method: GET
    headers: "{{ forti_wazuh_opensearch_headers }}"
    validate_certs: "{{ forti_wazuh_opensearch_validate_certs }}"
    url_username: "{{ forti_wazuh_opensearch_username if forti_wazuh_opensearch_auth_method == 'basic' else omit }}"
    url_password: "{{ forti_wazuh_opensearch_password if forti_wazuh_opensearch_auth_method == 'basic' else omit }}"
    force_basic_auth: "{{ true if forti_wazuh_opensearch_auth_method == 'basic' else omit }}"
    status_code: [200, 403, 404]
  register: forti_wazuh_opensearch_pipeline_list
  failed_when: false
  when:
    - forti_wazuh_archives_pipeline_manage
    - forti_wazuh_archives_pipeline_name | trim | length == 0
  no_log: true

- name: Determine archives ingest pipeline name
  ansible.builtin.set_fact:
    forti_wazuh_archives_pipeline_name_effective: >-
      {{
        (forti_wazuh_archives_pipeline_name | default('') | trim)
        if (forti_wazuh_archives_pipeline_name | default('') | trim | length > 0)
        else (
          (forti_wazuh_opensearch_pipeline_list.json.keys() | list
            | select('search', forti_wazuh_archives_pipeline_match)
            | list | first | default(''))
          if (forti_wazuh_opensearch_pipeline_list.status | default(0) == 200)
          else ''
        )
      }}
  when: forti_wazuh_archives_pipeline_manage

- name: Warn if archives ingest pipeline could not be determined
  ansible.builtin.debug:
    msg: >-
      Could not determine archives ingest pipeline name. Set forti_wazuh_archives_pipeline_name
      or adjust forti_wazuh_archives_pipeline_match.
  when:
    - forti_wazuh_archives_pipeline_manage
    - forti_wazuh_archives_pipeline_name_effective | length == 0

- name: Fetch archives ingest pipeline
  ansible.builtin.uri:
    url: "{{ forti_wazuh_opensearch_url_base }}/_ingest/pipeline/{{ forti_wazuh_archives_pipeline_name_effective }}"
    method: GET
    headers: "{{ forti_wazuh_opensearch_headers }}"
    validate_certs: "{{ forti_wazuh_opensearch_validate_certs }}"
    url_username: "{{ forti_wazuh_opensearch_username if forti_wazuh_opensearch_auth_method == 'basic' else omit }}"
    url_password: "{{ forti_wazuh_opensearch_password if forti_wazuh_opensearch_auth_method == 'basic' else omit }}"
    force_basic_auth: "{{ true if forti_wazuh_opensearch_auth_method == 'basic' else omit }}"
    status_code: [200, 403, 404]
  register: forti_wazuh_archives_pipeline_get
  failed_when: false
  when:
    - forti_wazuh_archives_pipeline_manage
    - forti_wazuh_archives_pipeline_name_effective | length > 0
  no_log: true

- name: Determine archives severity mode for pipeline
  ansible.builtin.set_fact:
    forti_wazuh_archives_pipeline_severity_mode_effective: >-
      {{
        (forti_wazuh_archives_severity_mode | default('') | lower | trim)
        if (forti_wazuh_archives_severity_mode | default('') | trim | length > 0)
        else (
          (forti_wazuh_archives_include_severity is defined and forti_wazuh_archives_include_severity is not none)
          | ternary(
              (forti_wazuh_archives_include_severity | default(false, true) | bool) | ternary('keep', 'drop'),
              (forti_wazuh_archives_clear_severity | default(true, true) | bool) | ternary('drop', 'keep')
            )
        )
      }}
  when:
    - forti_wazuh_archives_pipeline_manage
    - forti_wazuh_archives_pipeline_get.status | default(0) == 200

- name: Build archives pipeline rule.level processors
  ansible.builtin.set_fact:
    forti_wazuh_archives_pipeline_rule_level_processors: >-
      {{
        [] if (forti_wazuh_archives_pipeline_severity_mode_effective == 'keep')
        else (
          (forti_wazuh_archives_pipeline_severity_mode_effective == 'zero')
          | ternary(
              [{'set': {'field': 'rule.level', 'value': 0, 'override': true, 'tag': 'forti_wazuh_archives_rule_level'}}],
              [{'remove': {'field': 'rule.level', 'ignore_missing': true, 'tag': 'forti_wazuh_archives_rule_level'}}]
            )
        )
      }}
  when:
    - forti_wazuh_archives_pipeline_manage
    - forti_wazuh_archives_pipeline_get.status | default(0) == 200

- name: Prepare updated archives ingest pipeline
  ansible.builtin.set_fact:
    forti_wazuh_archives_pipeline_current: "{{ forti_wazuh_archives_pipeline_get.json[forti_wazuh_archives_pipeline_name_effective] }}"
    forti_wazuh_archives_pipeline_processors_updated: >-
      {{
        (
          (forti_wazuh_archives_pipeline_get.json[forti_wazuh_archives_pipeline_name_effective].processors | default([]))
          | reject('search', 'forti_wazuh_archives_rule_level')
          | list
        )
        + forti_wazuh_archives_pipeline_rule_level_processors
      }}
  when:
    - forti_wazuh_archives_pipeline_manage
    - forti_wazuh_archives_pipeline_get.status | default(0) == 200

- name: Update archives ingest pipeline rule.level handling
  ansible.builtin.uri:
    url: "{{ forti_wazuh_opensearch_url_base }}/_ingest/pipeline/{{ forti_wazuh_archives_pipeline_name_effective }}"
    method: PUT
    headers: "{{ forti_wazuh_opensearch_headers }}"
    body_format: json
    body: >-
      {{
        forti_wazuh_archives_pipeline_current
        | combine({'processors': forti_wazuh_archives_pipeline_processors_updated})
      }}
    validate_certs: "{{ forti_wazuh_opensearch_validate_certs }}"
    url_username: "{{ forti_wazuh_opensearch_username if forti_wazuh_opensearch_auth_method == 'basic' else omit }}"
    url_password: "{{ forti_wazuh_opensearch_password if forti_wazuh_opensearch_auth_method == 'basic' else omit }}"
    force_basic_auth: "{{ true if forti_wazuh_opensearch_auth_method == 'basic' else omit }}"
    status_code: [200]
  when:
    - forti_wazuh_archives_pipeline_manage
    - forti_wazuh_archives_pipeline_get.status | default(0) == 200
    - forti_wazuh_archives_pipeline_current.processors | default([]) != forti_wazuh_archives_pipeline_processors_updated
  no_log: true

- name: Warn if archives ingest pipeline could not be accessed
  ansible.builtin.debug:
    msg: >-
      OpenSearch API returned HTTP {{ forti_wazuh_archives_pipeline_get.status }} for ingest pipeline.
      Skipping archives rule.level handling. Check OpenSearch credentials or URL.
  when:
    - forti_wazuh_archives_pipeline_manage
    - forti_wazuh_archives_pipeline_name_effective | length > 0
    - forti_wazuh_archives_pipeline_get.status | default(0) != 200

# --- Wazuh Dashboards index pattern (optional) ---
- name: Validate Dashboards API configuration
  ansible.builtin.assert:
    that:
      - forti_wazuh_dashboards_url | length > 0
      - forti_wazuh_dashboards_auth_method in ["basic", "token", "none"]
      - forti_wazuh_dashboards_auth_method != "basic" or (forti_wazuh_dashboards_username | length > 0 and forti_wazuh_dashboards_password | length > 0)
      - forti_wazuh_dashboards_auth_method != "token" or (forti_wazuh_dashboards_token | length > 0)
    fail_msg: >-
      Dashboards API is enabled but required settings are missing.
      Set forti_wazuh_dashboards_url and the appropriate auth variables
      (forti_wazuh_dashboards_username/password or forti_wazuh_dashboards_token),
      or set forti_wazuh_dashboards_manage=false.
  when: forti_wazuh_dashboards_manage

- name: Normalize Dashboards URL
  ansible.builtin.set_fact:
    forti_wazuh_dashboards_url_base: "{{ forti_wazuh_dashboards_url | regex_replace('/+$', '') }}"
  when: forti_wazuh_dashboards_manage

- name: Determine Dashboards XSRF header
  ansible.builtin.set_fact:
    forti_wazuh_dashboards_xsrf_header: >-
      {{ "osd-xsrf" if (forti_wazuh_dashboards_version | lower).startswith("2") else "kbn-xsrf" }}
  when: forti_wazuh_dashboards_manage

- name: Build Dashboards request headers
  ansible.builtin.set_fact:
    forti_wazuh_dashboards_headers: >-
      {{
        {forti_wazuh_dashboards_xsrf_header: "true", "Content-Type": "application/json"}
        | combine(
            (forti_wazuh_dashboards_auth_method == "token")
            | ternary({"Authorization": "Bearer " ~ forti_wazuh_dashboards_token}, {})
          )
        | combine(
            (
              (forti_wazuh_dashboards_tenant | length > 0)
              and (forti_wazuh_dashboards_version | lower).startswith("2")
            )
            | ternary({"securitytenant": forti_wazuh_dashboards_tenant}, {})
          )
      }}
  when: forti_wazuh_dashboards_manage
  no_log: true

- name: Determine Dashboards settings API paths
  ansible.builtin.set_fact:
    forti_wazuh_dashboards_settings_paths: >-
      {{
        (forti_wazuh_dashboards_version | lower).startswith("2")
        | ternary(
            ["/api/opensearch_dashboards/settings", "/api/opensearch-dashboards/settings", "/api/ui_settings"],
            ["/api/kibana/settings", "/api/ui_settings"]
          )
      }}
  when: forti_wazuh_dashboards_manage

- name: Set Dashboards timezone
  ansible.builtin.uri:
    url: "{{ forti_wazuh_dashboards_url_base }}{{ item }}"
    method: POST
    headers: "{{ forti_wazuh_dashboards_headers }}"
    body_format: json
    body:
      changes:
        "dateFormat:tz": "{{ forti_wazuh_dashboards_timezone }}"
    status_code: [200, 204, 404]
    validate_certs: "{{ forti_wazuh_dashboards_validate_certs }}"
    url_username: "{{ forti_wazuh_dashboards_username if forti_wazuh_dashboards_auth_method == 'basic' else omit }}"
    url_password: "{{ forti_wazuh_dashboards_password if forti_wazuh_dashboards_auth_method == 'basic' else omit }}"
    force_basic_auth: "{{ true if forti_wazuh_dashboards_auth_method == 'basic' else omit }}"
  register: forti_wazuh_dashboards_timezone_attempts
  loop: "{{ forti_wazuh_dashboards_settings_paths }}"
  failed_when: false
  when:
    - forti_wazuh_dashboards_manage
    - forti_wazuh_dashboards_timezone | length > 0
  no_log: true

- name: Determine if Dashboards timezone was updated
  ansible.builtin.set_fact:
    forti_wazuh_dashboards_timezone_set: >-
      {{
        (forti_wazuh_dashboards_timezone_attempts.results
          | selectattr("status", "in", [200, 204])
          | list
          | length) > 0
      }}
  when:
    - forti_wazuh_dashboards_manage
    - forti_wazuh_dashboards_timezone | length > 0

- name: Warn if Dashboards timezone could not be set
  ansible.builtin.debug:
    msg: >-
      Dashboards timezone could not be set (tried {{ forti_wazuh_dashboards_settings_paths | join(", ") }}).
      Check forti_wazuh_dashboards_url and any proxy/base-path settings.
  when:
    - forti_wazuh_dashboards_manage
    - forti_wazuh_dashboards_timezone | length > 0
    - not (forti_wazuh_dashboards_timezone_set | default(false))

- name: Check for Wazuh archives index pattern
  ansible.builtin.uri:
    url: "{{ forti_wazuh_dashboards_url_base }}/api/saved_objects/_find?type=index-pattern&search_fields=title&search={{ forti_wazuh_dashboards_archives_pattern | urlencode }}"
    method: GET
    headers: "{{ forti_wazuh_dashboards_headers }}"
    return_content: true
    status_code: [200, 403, 404]
    validate_certs: "{{ forti_wazuh_dashboards_validate_certs }}"
    url_username: "{{ forti_wazuh_dashboards_username if forti_wazuh_dashboards_auth_method == 'basic' else omit }}"
    url_password: "{{ forti_wazuh_dashboards_password if forti_wazuh_dashboards_auth_method == 'basic' else omit }}"
    force_basic_auth: "{{ true if forti_wazuh_dashboards_auth_method == 'basic' else omit }}"
  register: forti_wazuh_dashboards_archives_find
  failed_when: false
  when: forti_wazuh_dashboards_manage
  no_log: true

- name: Determine if archives index pattern API is available
  ansible.builtin.set_fact:
    forti_wazuh_dashboards_archives_api_ok: "{{ forti_wazuh_dashboards_archives_find.status == 200 }}"
  when: forti_wazuh_dashboards_manage

- name: Determine if archives index pattern exists
  ansible.builtin.set_fact:
    forti_wazuh_dashboards_archives_pattern_exists: >-
      {{
        forti_wazuh_dashboards_archives_api_ok
        and (forti_wazuh_dashboards_archives_find.json.total | default(0) | int) > 0
      }}
  when: forti_wazuh_dashboards_manage

- name: Warn if archives index pattern API is not accessible
  ansible.builtin.debug:
    msg: >-
      Dashboards API returned HTTP {{ forti_wazuh_dashboards_archives_find.status }} for saved_objects.
      Skipping archives index pattern creation. Check credentials/roles or proxy/base-path settings.
  when:
    - forti_wazuh_dashboards_manage
    - not (forti_wazuh_dashboards_archives_api_ok | default(false))

- name: Create Wazuh archives index pattern
  ansible.builtin.uri:
    url: "{{ forti_wazuh_dashboards_url_base }}/api/saved_objects/index-pattern/{{ forti_wazuh_dashboards_archives_pattern_id | urlencode }}"
    method: POST
    headers: "{{ forti_wazuh_dashboards_headers }}"
    body_format: json
    body:
      attributes:
        title: "{{ forti_wazuh_dashboards_archives_pattern }}"
        timeFieldName: "{{ forti_wazuh_dashboards_archives_time_field }}"
    status_code: [200, 201]
    validate_certs: "{{ forti_wazuh_dashboards_validate_certs }}"
    url_username: "{{ forti_wazuh_dashboards_username if forti_wazuh_dashboards_auth_method == 'basic' else omit }}"
    url_password: "{{ forti_wazuh_dashboards_password if forti_wazuh_dashboards_auth_method == 'basic' else omit }}"
    force_basic_auth: "{{ true if forti_wazuh_dashboards_auth_method == 'basic' else omit }}"
  when:
    - forti_wazuh_dashboards_manage
    - forti_wazuh_dashboards_archives_api_ok | default(false)
    - not forti_wazuh_dashboards_archives_pattern_exists
  no_log: true
